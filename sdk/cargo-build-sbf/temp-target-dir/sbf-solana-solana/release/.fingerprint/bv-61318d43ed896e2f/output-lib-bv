{"$message_type":"diagnostic","message":"unnecessary parentheses around block return value","code":{"code":"unused_parens","explanation":null},"level":"warning","spans":[{"file_name":"src/slice.rs","byte_start":4134,"byte_end":4135,"line_start":112,"line_end":112,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"                (chunk1 | (chunk2 << shift2))","highlight_start":17,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/slice.rs","byte_start":4162,"byte_end":4163,"line_start":112,"line_end":112,"column_start":45,"column_end":46,"is_primary":true,"text":[{"text":"                (chunk1 | (chunk2 << shift2))","highlight_start":45,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_parens)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove these parentheses","code":null,"level":"help","spans":[{"file_name":"src/slice.rs","byte_start":4134,"byte_end":4135,"line_start":112,"line_end":112,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"                (chunk1 | (chunk2 << shift2))","highlight_start":17,"highlight_end":18}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/slice.rs","byte_start":4162,"byte_end":4163,"line_start":112,"line_end":112,"column_start":45,"column_end":46,"is_primary":true,"text":[{"text":"                (chunk1 | (chunk2 << shift2))","highlight_start":45,"highlight_end":46}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unnecessary parentheses around block return value\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/slice.rs:112:17\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                (chunk1 | (chunk2 << shift2))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_parens)]` on by default\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: remove these parentheses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[38;5;9m(\u001b[0m\u001b[0mchunk1 | (chunk2 << shift2)\u001b[0m\u001b[0m\u001b[38;5;9m)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m                chunk1 | (chunk2 << shift2)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary parentheses around block return value","code":{"code":"unused_parens","explanation":null},"level":"warning","spans":[{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":7235,"byte_end":7236,"line_start":205,"line_end":205,"column_start":9,"column_end":10,"is_primary":true,"text":[{"text":"        (start + len - real_start)","highlight_start":9,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":7260,"byte_end":7261,"line_start":205,"line_end":205,"column_start":34,"column_end":35,"is_primary":true,"text":[{"text":"        (start + len - real_start)","highlight_start":34,"highlight_end":35}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove these parentheses","code":null,"level":"help","spans":[{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":7235,"byte_end":7236,"line_start":205,"line_end":205,"column_start":9,"column_end":10,"is_primary":true,"text":[{"text":"        (start + len - real_start)","highlight_start":9,"highlight_end":10}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":7260,"byte_end":7261,"line_start":205,"line_end":205,"column_start":34,"column_end":35,"is_primary":true,"text":[{"text":"        (start + len - real_start)","highlight_start":34,"highlight_end":35}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unnecessary parentheses around block return value\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/adapter/bit_slice_adapter.rs:205:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m205\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        (start + len - real_start)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: remove these parentheses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m205\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[38;5;9m(\u001b[0m\u001b[0mstart + len - real_start\u001b[0m\u001b[0m\u001b[38;5;9m)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m205\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        start + len - real_start\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"panic message is not a string literal","code":{"code":"non_fmt_panics","explanation":null},"level":"warning","spans":[{"file_name":"src/traits/bits.rs","byte_start":2050,"byte_end":2151,"line_start":62,"line_end":63,"column_start":17,"column_end":52,"is_primary":true,"text":[{"text":"                format!(\"Bits::get_block: out of bounds ({}/{})\",","highlight_start":17,"highlight_end":66},{"text":"                        position, self.block_len()));","highlight_start":1,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the `assert!()` macro supports formatting, so there's no need for the `format!()` macro here","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`#[warn(non_fmt_panics)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the `format!(..)` macro call","code":null,"level":"help","spans":[{"file_name":"src/traits/bits.rs","byte_start":2050,"byte_end":2058,"line_start":62,"line_end":62,"column_start":17,"column_end":25,"is_primary":true,"text":[{"text":"                format!(\"Bits::get_block: out of bounds ({}/{})\",","highlight_start":17,"highlight_end":25}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/traits/bits.rs","byte_start":2150,"byte_end":2151,"line_start":63,"line_end":63,"column_start":51,"column_end":52,"is_primary":true,"text":[{"text":"                        position, self.block_len()));","highlight_start":51,"highlight_end":52}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: panic message is not a string literal\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/traits/bits.rs:62:17\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m62\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m                format!(\"Bits::get_block: out of bounds ({}/{})\",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m63\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        position, self.block_len()));\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|___________________________________________________^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the `assert!()` macro supports formatting, so there's no need for the `format!()` macro here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(non_fmt_panics)]` on by default\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: remove the `format!(..)` macro call\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m62\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                \"Bits::get_block: out of bounds ({}/{})\",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m63\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                        position, self.block_len());\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"panic message is not a string literal","code":{"code":"non_fmt_panics","explanation":null},"level":"warning","spans":[{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2626,"byte_end":2678,"line_start":90,"line_end":90,"column_start":30,"column_end":82,"is_primary":true,"text":[{"text":"                             format!(\"{}::slice: bad range\", stringify!($target)) );","highlight_start":30,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":3652,"byte_end":3737,"line_start":145,"line_end":147,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"impl_bit_sliceable_adapter! {","highlight_start":1,"highlight_end":30},{"text":"    impl['a, T: Bits] BitSliceable for &'a BitNot<T>;","highlight_start":1,"highlight_end":54},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bit_sliceable_adapter!","def_site_span":{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2157,"byte_end":2196,"line_start":78,"line_end":78,"column_start":1,"column_end":40,"is_primary":false,"text":[{"text":"macro_rules! impl_bit_sliceable_adapter {","highlight_start":1,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the `assert!()` macro supports formatting, so there's no need for the `format!()` macro here","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the `format!(..)` macro call","code":null,"level":"help","spans":[{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2626,"byte_end":2634,"line_start":90,"line_end":90,"column_start":30,"column_end":38,"is_primary":true,"text":[{"text":"                             format!(\"{}::slice: bad range\", stringify!($target)) );","highlight_start":30,"highlight_end":38}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":3652,"byte_end":3737,"line_start":145,"line_end":147,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"impl_bit_sliceable_adapter! {","highlight_start":1,"highlight_end":30},{"text":"    impl['a, T: Bits] BitSliceable for &'a BitNot<T>;","highlight_start":1,"highlight_end":54},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bit_sliceable_adapter!","def_site_span":{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2157,"byte_end":2196,"line_start":78,"line_end":78,"column_start":1,"column_end":40,"is_primary":false,"text":[{"text":"macro_rules! impl_bit_sliceable_adapter {","highlight_start":1,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2677,"byte_end":2678,"line_start":90,"line_end":90,"column_start":81,"column_end":82,"is_primary":true,"text":[{"text":"                             format!(\"{}::slice: bad range\", stringify!($target)) );","highlight_start":81,"highlight_end":82}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":3652,"byte_end":3737,"line_start":145,"line_end":147,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"impl_bit_sliceable_adapter! {","highlight_start":1,"highlight_end":30},{"text":"    impl['a, T: Bits] BitSliceable for &'a BitNot<T>;","highlight_start":1,"highlight_end":54},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bit_sliceable_adapter!","def_site_span":{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2157,"byte_end":2196,"line_start":78,"line_end":78,"column_start":1,"column_end":40,"is_primary":false,"text":[{"text":"macro_rules! impl_bit_sliceable_adapter {","highlight_start":1,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: panic message is not a string literal\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/adapter/bit_slice_adapter.rs:90:30\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m90\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   format!(\"{}::slice: bad range\", stringify!($target)) );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/adapter/logic.rs:145:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m145\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_bit_sliceable_adapter! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m146\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    impl['a, T: Bits] BitSliceable for &'a BitNot<T>;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m147\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the `assert!()` macro supports formatting, so there's no need for the `format!()` macro here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this warning originates in the macro `impl_bit_sliceable_adapter` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: remove the `format!(..)` macro call\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m90\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[38;5;9mformat!(\u001b[0m\u001b[0m\"{}::slice: bad range\", stringify!($target)\u001b[0m\u001b[0m\u001b[38;5;9m)\u001b[0m\u001b[0m );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m90\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m                             \"{}::slice: bad range\", stringify!($target) );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"panic message is not a string literal","code":{"code":"non_fmt_panics","explanation":null},"level":"warning","spans":[{"file_name":"src/adapter/logic.rs","byte_start":4395,"byte_end":4453,"line_start":172,"line_end":172,"column_start":26,"column_end":84,"is_primary":true,"text":[{"text":"                         format!(\"{}::get_bit: out of bounds\", stringify!($target)) );","highlight_start":26,"highlight_end":84}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":6081,"byte_end":6114,"line_start":221,"line_end":221,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"impl_bits_bin_op!(BitAnd as & &&);","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bits_bin_op!","def_site_span":{"file_name":"src/adapter/logic.rs","byte_start":3936,"byte_end":3965,"line_start":158,"line_end":158,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! impl_bits_bin_op {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the `assert!()` macro supports formatting, so there's no need for the `format!()` macro here","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the `format!(..)` macro call","code":null,"level":"help","spans":[{"file_name":"src/adapter/logic.rs","byte_start":4395,"byte_end":4403,"line_start":172,"line_end":172,"column_start":26,"column_end":34,"is_primary":true,"text":[{"text":"                         format!(\"{}::get_bit: out of bounds\", stringify!($target)) );","highlight_start":26,"highlight_end":34}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":6081,"byte_end":6114,"line_start":221,"line_end":221,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"impl_bits_bin_op!(BitAnd as & &&);","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bits_bin_op!","def_site_span":{"file_name":"src/adapter/logic.rs","byte_start":3936,"byte_end":3965,"line_start":158,"line_end":158,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! impl_bits_bin_op {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/adapter/logic.rs","byte_start":4452,"byte_end":4453,"line_start":172,"line_end":172,"column_start":83,"column_end":84,"is_primary":true,"text":[{"text":"                         format!(\"{}::get_bit: out of bounds\", stringify!($target)) );","highlight_start":83,"highlight_end":84}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":6081,"byte_end":6114,"line_start":221,"line_end":221,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"impl_bits_bin_op!(BitAnd as & &&);","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bits_bin_op!","def_site_span":{"file_name":"src/adapter/logic.rs","byte_start":3936,"byte_end":3965,"line_start":158,"line_end":158,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! impl_bits_bin_op {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: panic message is not a string literal\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/adapter/logic.rs:172:26\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m172\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                         format!(\"{}::get_bit: out of bounds\", stringify!($target)) );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m221\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_bits_bin_op!(BitAnd as & &&);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the `assert!()` macro supports formatting, so there's no need for the `format!()` macro here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this warning originates in the macro `impl_bits_bin_op` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: remove the `format!(..)` macro call\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m172\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[38;5;9mformat!(\u001b[0m\u001b[0m\"{}::get_bit: out of bounds\", stringify!($target)\u001b[0m\u001b[0m\u001b[38;5;9m)\u001b[0m\u001b[0m );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m172\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m                         \"{}::get_bit: out of bounds\", stringify!($target) );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"panic message is not a string literal","code":{"code":"non_fmt_panics","explanation":null},"level":"warning","spans":[{"file_name":"src/adapter/logic.rs","byte_start":4686,"byte_end":4746,"line_start":178,"line_end":178,"column_start":26,"column_end":86,"is_primary":true,"text":[{"text":"                         format!(\"{}::get_block: out of bounds\", stringify!($target)) );","highlight_start":26,"highlight_end":86}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":6081,"byte_end":6114,"line_start":221,"line_end":221,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"impl_bits_bin_op!(BitAnd as & &&);","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bits_bin_op!","def_site_span":{"file_name":"src/adapter/logic.rs","byte_start":3936,"byte_end":3965,"line_start":158,"line_end":158,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! impl_bits_bin_op {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the `assert!()` macro supports formatting, so there's no need for the `format!()` macro here","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the `format!(..)` macro call","code":null,"level":"help","spans":[{"file_name":"src/adapter/logic.rs","byte_start":4686,"byte_end":4694,"line_start":178,"line_end":178,"column_start":26,"column_end":34,"is_primary":true,"text":[{"text":"                         format!(\"{}::get_block: out of bounds\", stringify!($target)) );","highlight_start":26,"highlight_end":34}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":6081,"byte_end":6114,"line_start":221,"line_end":221,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"impl_bits_bin_op!(BitAnd as & &&);","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bits_bin_op!","def_site_span":{"file_name":"src/adapter/logic.rs","byte_start":3936,"byte_end":3965,"line_start":158,"line_end":158,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! impl_bits_bin_op {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/adapter/logic.rs","byte_start":4745,"byte_end":4746,"line_start":178,"line_end":178,"column_start":85,"column_end":86,"is_primary":true,"text":[{"text":"                         format!(\"{}::get_block: out of bounds\", stringify!($target)) );","highlight_start":85,"highlight_end":86}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":6081,"byte_end":6114,"line_start":221,"line_end":221,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"impl_bits_bin_op!(BitAnd as & &&);","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bits_bin_op!","def_site_span":{"file_name":"src/adapter/logic.rs","byte_start":3936,"byte_end":3965,"line_start":158,"line_end":158,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! impl_bits_bin_op {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: panic message is not a string literal\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/adapter/logic.rs:178:26\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m178\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                         format!(\"{}::get_block: out of bounds\", stringify!($target)) );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m221\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_bits_bin_op!(BitAnd as & &&);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the `assert!()` macro supports formatting, so there's no need for the `format!()` macro here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this warning originates in the macro `impl_bits_bin_op` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: remove the `format!(..)` macro call\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m178\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[38;5;9mformat!(\u001b[0m\u001b[0m\"{}::get_block: out of bounds\", stringify!($target)\u001b[0m\u001b[0m\u001b[38;5;9m)\u001b[0m\u001b[0m );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m178\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m                         \"{}::get_block: out of bounds\", stringify!($target) );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"panic message is not a string literal","code":{"code":"non_fmt_panics","explanation":null},"level":"warning","spans":[{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2626,"byte_end":2678,"line_start":90,"line_end":90,"column_start":30,"column_end":82,"is_primary":true,"text":[{"text":"                             format!(\"{}::slice: bad range\", stringify!($target)) );","highlight_start":30,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":5633,"byte_end":5765,"line_start":205,"line_end":207,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        impl_bit_sliceable_adapter! {","highlight_start":9,"highlight_end":38},{"text":"            impl['a, T: Bits, U: Bits<Block = T::Block>] BitSliceable for &'a $target<T, U>;","highlight_start":1,"highlight_end":93},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":6081,"byte_end":6114,"line_start":221,"line_end":221,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"impl_bits_bin_op!(BitAnd as & &&);","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bits_bin_op!","def_site_span":{"file_name":"src/adapter/logic.rs","byte_start":3936,"byte_end":3965,"line_start":158,"line_end":158,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! impl_bits_bin_op {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"impl_bit_sliceable_adapter!","def_site_span":{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2157,"byte_end":2196,"line_start":78,"line_end":78,"column_start":1,"column_end":40,"is_primary":false,"text":[{"text":"macro_rules! impl_bit_sliceable_adapter {","highlight_start":1,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the `assert!()` macro supports formatting, so there's no need for the `format!()` macro here","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the `format!(..)` macro call","code":null,"level":"help","spans":[{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2626,"byte_end":2634,"line_start":90,"line_end":90,"column_start":30,"column_end":38,"is_primary":true,"text":[{"text":"                             format!(\"{}::slice: bad range\", stringify!($target)) );","highlight_start":30,"highlight_end":38}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":5633,"byte_end":5765,"line_start":205,"line_end":207,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        impl_bit_sliceable_adapter! {","highlight_start":9,"highlight_end":38},{"text":"            impl['a, T: Bits, U: Bits<Block = T::Block>] BitSliceable for &'a $target<T, U>;","highlight_start":1,"highlight_end":93},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":6081,"byte_end":6114,"line_start":221,"line_end":221,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"impl_bits_bin_op!(BitAnd as & &&);","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bits_bin_op!","def_site_span":{"file_name":"src/adapter/logic.rs","byte_start":3936,"byte_end":3965,"line_start":158,"line_end":158,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! impl_bits_bin_op {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"impl_bit_sliceable_adapter!","def_site_span":{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2157,"byte_end":2196,"line_start":78,"line_end":78,"column_start":1,"column_end":40,"is_primary":false,"text":[{"text":"macro_rules! impl_bit_sliceable_adapter {","highlight_start":1,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2677,"byte_end":2678,"line_start":90,"line_end":90,"column_start":81,"column_end":82,"is_primary":true,"text":[{"text":"                             format!(\"{}::slice: bad range\", stringify!($target)) );","highlight_start":81,"highlight_end":82}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":5633,"byte_end":5765,"line_start":205,"line_end":207,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        impl_bit_sliceable_adapter! {","highlight_start":9,"highlight_end":38},{"text":"            impl['a, T: Bits, U: Bits<Block = T::Block>] BitSliceable for &'a $target<T, U>;","highlight_start":1,"highlight_end":93},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":6081,"byte_end":6114,"line_start":221,"line_end":221,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"impl_bits_bin_op!(BitAnd as & &&);","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bits_bin_op!","def_site_span":{"file_name":"src/adapter/logic.rs","byte_start":3936,"byte_end":3965,"line_start":158,"line_end":158,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! impl_bits_bin_op {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"impl_bit_sliceable_adapter!","def_site_span":{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2157,"byte_end":2196,"line_start":78,"line_end":78,"column_start":1,"column_end":40,"is_primary":false,"text":[{"text":"macro_rules! impl_bit_sliceable_adapter {","highlight_start":1,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: panic message is not a string literal\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/adapter/bit_slice_adapter.rs:90:30\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m90\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   format!(\"{}::slice: bad range\", stringify!($target)) );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/adapter/logic.rs:221:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m221\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_bits_bin_op!(BitAnd as & &&);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the `assert!()` macro supports formatting, so there's no need for the `format!()` macro here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this warning originates in the macro `impl_bit_sliceable_adapter` which comes from the expansion of the macro `impl_bits_bin_op` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: remove the `format!(..)` macro call\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m90\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[38;5;9mformat!(\u001b[0m\u001b[0m\"{}::slice: bad range\", stringify!($target)\u001b[0m\u001b[0m\u001b[38;5;9m)\u001b[0m\u001b[0m );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m90\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m                             \"{}::slice: bad range\", stringify!($target) );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"panic message is not a string literal","code":{"code":"non_fmt_panics","explanation":null},"level":"warning","spans":[{"file_name":"src/adapter/logic.rs","byte_start":4395,"byte_end":4453,"line_start":172,"line_end":172,"column_start":26,"column_end":84,"is_primary":true,"text":[{"text":"                         format!(\"{}::get_bit: out of bounds\", stringify!($target)) );","highlight_start":26,"highlight_end":84}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":6116,"byte_end":6149,"line_start":222,"line_end":222,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"impl_bits_bin_op!(BitOr  as | ||);","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bits_bin_op!","def_site_span":{"file_name":"src/adapter/logic.rs","byte_start":3936,"byte_end":3965,"line_start":158,"line_end":158,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! impl_bits_bin_op {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the `assert!()` macro supports formatting, so there's no need for the `format!()` macro here","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the `format!(..)` macro call","code":null,"level":"help","spans":[{"file_name":"src/adapter/logic.rs","byte_start":4395,"byte_end":4403,"line_start":172,"line_end":172,"column_start":26,"column_end":34,"is_primary":true,"text":[{"text":"                         format!(\"{}::get_bit: out of bounds\", stringify!($target)) );","highlight_start":26,"highlight_end":34}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":6116,"byte_end":6149,"line_start":222,"line_end":222,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"impl_bits_bin_op!(BitOr  as | ||);","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bits_bin_op!","def_site_span":{"file_name":"src/adapter/logic.rs","byte_start":3936,"byte_end":3965,"line_start":158,"line_end":158,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! impl_bits_bin_op {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/adapter/logic.rs","byte_start":4452,"byte_end":4453,"line_start":172,"line_end":172,"column_start":83,"column_end":84,"is_primary":true,"text":[{"text":"                         format!(\"{}::get_bit: out of bounds\", stringify!($target)) );","highlight_start":83,"highlight_end":84}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":6116,"byte_end":6149,"line_start":222,"line_end":222,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"impl_bits_bin_op!(BitOr  as | ||);","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bits_bin_op!","def_site_span":{"file_name":"src/adapter/logic.rs","byte_start":3936,"byte_end":3965,"line_start":158,"line_end":158,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! impl_bits_bin_op {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: panic message is not a string literal\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/adapter/logic.rs:172:26\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m172\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                         format!(\"{}::get_bit: out of bounds\", stringify!($target)) );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m222\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_bits_bin_op!(BitOr  as | ||);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the `assert!()` macro supports formatting, so there's no need for the `format!()` macro here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this warning originates in the macro `impl_bits_bin_op` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: remove the `format!(..)` macro call\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m172\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[38;5;9mformat!(\u001b[0m\u001b[0m\"{}::get_bit: out of bounds\", stringify!($target)\u001b[0m\u001b[0m\u001b[38;5;9m)\u001b[0m\u001b[0m );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m172\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m                         \"{}::get_bit: out of bounds\", stringify!($target) );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"panic message is not a string literal","code":{"code":"non_fmt_panics","explanation":null},"level":"warning","spans":[{"file_name":"src/adapter/logic.rs","byte_start":4686,"byte_end":4746,"line_start":178,"line_end":178,"column_start":26,"column_end":86,"is_primary":true,"text":[{"text":"                         format!(\"{}::get_block: out of bounds\", stringify!($target)) );","highlight_start":26,"highlight_end":86}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":6116,"byte_end":6149,"line_start":222,"line_end":222,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"impl_bits_bin_op!(BitOr  as | ||);","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bits_bin_op!","def_site_span":{"file_name":"src/adapter/logic.rs","byte_start":3936,"byte_end":3965,"line_start":158,"line_end":158,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! impl_bits_bin_op {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the `assert!()` macro supports formatting, so there's no need for the `format!()` macro here","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the `format!(..)` macro call","code":null,"level":"help","spans":[{"file_name":"src/adapter/logic.rs","byte_start":4686,"byte_end":4694,"line_start":178,"line_end":178,"column_start":26,"column_end":34,"is_primary":true,"text":[{"text":"                         format!(\"{}::get_block: out of bounds\", stringify!($target)) );","highlight_start":26,"highlight_end":34}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":6116,"byte_end":6149,"line_start":222,"line_end":222,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"impl_bits_bin_op!(BitOr  as | ||);","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bits_bin_op!","def_site_span":{"file_name":"src/adapter/logic.rs","byte_start":3936,"byte_end":3965,"line_start":158,"line_end":158,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! impl_bits_bin_op {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/adapter/logic.rs","byte_start":4745,"byte_end":4746,"line_start":178,"line_end":178,"column_start":85,"column_end":86,"is_primary":true,"text":[{"text":"                         format!(\"{}::get_block: out of bounds\", stringify!($target)) );","highlight_start":85,"highlight_end":86}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":6116,"byte_end":6149,"line_start":222,"line_end":222,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"impl_bits_bin_op!(BitOr  as | ||);","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bits_bin_op!","def_site_span":{"file_name":"src/adapter/logic.rs","byte_start":3936,"byte_end":3965,"line_start":158,"line_end":158,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! impl_bits_bin_op {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: panic message is not a string literal\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/adapter/logic.rs:178:26\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m178\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                         format!(\"{}::get_block: out of bounds\", stringify!($target)) );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m222\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_bits_bin_op!(BitOr  as | ||);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the `assert!()` macro supports formatting, so there's no need for the `format!()` macro here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this warning originates in the macro `impl_bits_bin_op` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: remove the `format!(..)` macro call\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m178\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[38;5;9mformat!(\u001b[0m\u001b[0m\"{}::get_block: out of bounds\", stringify!($target)\u001b[0m\u001b[0m\u001b[38;5;9m)\u001b[0m\u001b[0m );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m178\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m                         \"{}::get_block: out of bounds\", stringify!($target) );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"panic message is not a string literal","code":{"code":"non_fmt_panics","explanation":null},"level":"warning","spans":[{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2626,"byte_end":2678,"line_start":90,"line_end":90,"column_start":30,"column_end":82,"is_primary":true,"text":[{"text":"                             format!(\"{}::slice: bad range\", stringify!($target)) );","highlight_start":30,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":5633,"byte_end":5765,"line_start":205,"line_end":207,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        impl_bit_sliceable_adapter! {","highlight_start":9,"highlight_end":38},{"text":"            impl['a, T: Bits, U: Bits<Block = T::Block>] BitSliceable for &'a $target<T, U>;","highlight_start":1,"highlight_end":93},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":6116,"byte_end":6149,"line_start":222,"line_end":222,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"impl_bits_bin_op!(BitOr  as | ||);","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bits_bin_op!","def_site_span":{"file_name":"src/adapter/logic.rs","byte_start":3936,"byte_end":3965,"line_start":158,"line_end":158,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! impl_bits_bin_op {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"impl_bit_sliceable_adapter!","def_site_span":{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2157,"byte_end":2196,"line_start":78,"line_end":78,"column_start":1,"column_end":40,"is_primary":false,"text":[{"text":"macro_rules! impl_bit_sliceable_adapter {","highlight_start":1,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the `assert!()` macro supports formatting, so there's no need for the `format!()` macro here","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the `format!(..)` macro call","code":null,"level":"help","spans":[{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2626,"byte_end":2634,"line_start":90,"line_end":90,"column_start":30,"column_end":38,"is_primary":true,"text":[{"text":"                             format!(\"{}::slice: bad range\", stringify!($target)) );","highlight_start":30,"highlight_end":38}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":5633,"byte_end":5765,"line_start":205,"line_end":207,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        impl_bit_sliceable_adapter! {","highlight_start":9,"highlight_end":38},{"text":"            impl['a, T: Bits, U: Bits<Block = T::Block>] BitSliceable for &'a $target<T, U>;","highlight_start":1,"highlight_end":93},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":6116,"byte_end":6149,"line_start":222,"line_end":222,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"impl_bits_bin_op!(BitOr  as | ||);","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bits_bin_op!","def_site_span":{"file_name":"src/adapter/logic.rs","byte_start":3936,"byte_end":3965,"line_start":158,"line_end":158,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! impl_bits_bin_op {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"impl_bit_sliceable_adapter!","def_site_span":{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2157,"byte_end":2196,"line_start":78,"line_end":78,"column_start":1,"column_end":40,"is_primary":false,"text":[{"text":"macro_rules! impl_bit_sliceable_adapter {","highlight_start":1,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2677,"byte_end":2678,"line_start":90,"line_end":90,"column_start":81,"column_end":82,"is_primary":true,"text":[{"text":"                             format!(\"{}::slice: bad range\", stringify!($target)) );","highlight_start":81,"highlight_end":82}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":5633,"byte_end":5765,"line_start":205,"line_end":207,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        impl_bit_sliceable_adapter! {","highlight_start":9,"highlight_end":38},{"text":"            impl['a, T: Bits, U: Bits<Block = T::Block>] BitSliceable for &'a $target<T, U>;","highlight_start":1,"highlight_end":93},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":6116,"byte_end":6149,"line_start":222,"line_end":222,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"impl_bits_bin_op!(BitOr  as | ||);","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bits_bin_op!","def_site_span":{"file_name":"src/adapter/logic.rs","byte_start":3936,"byte_end":3965,"line_start":158,"line_end":158,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! impl_bits_bin_op {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"impl_bit_sliceable_adapter!","def_site_span":{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2157,"byte_end":2196,"line_start":78,"line_end":78,"column_start":1,"column_end":40,"is_primary":false,"text":[{"text":"macro_rules! impl_bit_sliceable_adapter {","highlight_start":1,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: panic message is not a string literal\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/adapter/bit_slice_adapter.rs:90:30\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m90\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   format!(\"{}::slice: bad range\", stringify!($target)) );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/adapter/logic.rs:222:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m222\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_bits_bin_op!(BitOr  as | ||);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the `assert!()` macro supports formatting, so there's no need for the `format!()` macro here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this warning originates in the macro `impl_bit_sliceable_adapter` which comes from the expansion of the macro `impl_bits_bin_op` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: remove the `format!(..)` macro call\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m90\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[38;5;9mformat!(\u001b[0m\u001b[0m\"{}::slice: bad range\", stringify!($target)\u001b[0m\u001b[0m\u001b[38;5;9m)\u001b[0m\u001b[0m );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m90\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m                             \"{}::slice: bad range\", stringify!($target) );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"panic message is not a string literal","code":{"code":"non_fmt_panics","explanation":null},"level":"warning","spans":[{"file_name":"src/adapter/logic.rs","byte_start":4395,"byte_end":4453,"line_start":172,"line_end":172,"column_start":26,"column_end":84,"is_primary":true,"text":[{"text":"                         format!(\"{}::get_bit: out of bounds\", stringify!($target)) );","highlight_start":26,"highlight_end":84}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":6151,"byte_end":6183,"line_start":223,"line_end":223,"column_start":1,"column_end":33,"is_primary":false,"text":[{"text":"impl_bits_bin_op!(BitXor as ^ ^);","highlight_start":1,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bits_bin_op!","def_site_span":{"file_name":"src/adapter/logic.rs","byte_start":3936,"byte_end":3965,"line_start":158,"line_end":158,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! impl_bits_bin_op {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the `assert!()` macro supports formatting, so there's no need for the `format!()` macro here","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the `format!(..)` macro call","code":null,"level":"help","spans":[{"file_name":"src/adapter/logic.rs","byte_start":4395,"byte_end":4403,"line_start":172,"line_end":172,"column_start":26,"column_end":34,"is_primary":true,"text":[{"text":"                         format!(\"{}::get_bit: out of bounds\", stringify!($target)) );","highlight_start":26,"highlight_end":34}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":6151,"byte_end":6183,"line_start":223,"line_end":223,"column_start":1,"column_end":33,"is_primary":false,"text":[{"text":"impl_bits_bin_op!(BitXor as ^ ^);","highlight_start":1,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bits_bin_op!","def_site_span":{"file_name":"src/adapter/logic.rs","byte_start":3936,"byte_end":3965,"line_start":158,"line_end":158,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! impl_bits_bin_op {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/adapter/logic.rs","byte_start":4452,"byte_end":4453,"line_start":172,"line_end":172,"column_start":83,"column_end":84,"is_primary":true,"text":[{"text":"                         format!(\"{}::get_bit: out of bounds\", stringify!($target)) );","highlight_start":83,"highlight_end":84}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":6151,"byte_end":6183,"line_start":223,"line_end":223,"column_start":1,"column_end":33,"is_primary":false,"text":[{"text":"impl_bits_bin_op!(BitXor as ^ ^);","highlight_start":1,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bits_bin_op!","def_site_span":{"file_name":"src/adapter/logic.rs","byte_start":3936,"byte_end":3965,"line_start":158,"line_end":158,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! impl_bits_bin_op {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: panic message is not a string literal\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/adapter/logic.rs:172:26\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m172\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                         format!(\"{}::get_bit: out of bounds\", stringify!($target)) );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m223\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_bits_bin_op!(BitXor as ^ ^);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the `assert!()` macro supports formatting, so there's no need for the `format!()` macro here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this warning originates in the macro `impl_bits_bin_op` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: remove the `format!(..)` macro call\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m172\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[38;5;9mformat!(\u001b[0m\u001b[0m\"{}::get_bit: out of bounds\", stringify!($target)\u001b[0m\u001b[0m\u001b[38;5;9m)\u001b[0m\u001b[0m );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m172\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m                         \"{}::get_bit: out of bounds\", stringify!($target) );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"panic message is not a string literal","code":{"code":"non_fmt_panics","explanation":null},"level":"warning","spans":[{"file_name":"src/adapter/logic.rs","byte_start":4686,"byte_end":4746,"line_start":178,"line_end":178,"column_start":26,"column_end":86,"is_primary":true,"text":[{"text":"                         format!(\"{}::get_block: out of bounds\", stringify!($target)) );","highlight_start":26,"highlight_end":86}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":6151,"byte_end":6183,"line_start":223,"line_end":223,"column_start":1,"column_end":33,"is_primary":false,"text":[{"text":"impl_bits_bin_op!(BitXor as ^ ^);","highlight_start":1,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bits_bin_op!","def_site_span":{"file_name":"src/adapter/logic.rs","byte_start":3936,"byte_end":3965,"line_start":158,"line_end":158,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! impl_bits_bin_op {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the `assert!()` macro supports formatting, so there's no need for the `format!()` macro here","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the `format!(..)` macro call","code":null,"level":"help","spans":[{"file_name":"src/adapter/logic.rs","byte_start":4686,"byte_end":4694,"line_start":178,"line_end":178,"column_start":26,"column_end":34,"is_primary":true,"text":[{"text":"                         format!(\"{}::get_block: out of bounds\", stringify!($target)) );","highlight_start":26,"highlight_end":34}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":6151,"byte_end":6183,"line_start":223,"line_end":223,"column_start":1,"column_end":33,"is_primary":false,"text":[{"text":"impl_bits_bin_op!(BitXor as ^ ^);","highlight_start":1,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bits_bin_op!","def_site_span":{"file_name":"src/adapter/logic.rs","byte_start":3936,"byte_end":3965,"line_start":158,"line_end":158,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! impl_bits_bin_op {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/adapter/logic.rs","byte_start":4745,"byte_end":4746,"line_start":178,"line_end":178,"column_start":85,"column_end":86,"is_primary":true,"text":[{"text":"                         format!(\"{}::get_block: out of bounds\", stringify!($target)) );","highlight_start":85,"highlight_end":86}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":6151,"byte_end":6183,"line_start":223,"line_end":223,"column_start":1,"column_end":33,"is_primary":false,"text":[{"text":"impl_bits_bin_op!(BitXor as ^ ^);","highlight_start":1,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bits_bin_op!","def_site_span":{"file_name":"src/adapter/logic.rs","byte_start":3936,"byte_end":3965,"line_start":158,"line_end":158,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! impl_bits_bin_op {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: panic message is not a string literal\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/adapter/logic.rs:178:26\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m178\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                         format!(\"{}::get_block: out of bounds\", stringify!($target)) );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m223\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_bits_bin_op!(BitXor as ^ ^);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the `assert!()` macro supports formatting, so there's no need for the `format!()` macro here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this warning originates in the macro `impl_bits_bin_op` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: remove the `format!(..)` macro call\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m178\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[38;5;9mformat!(\u001b[0m\u001b[0m\"{}::get_block: out of bounds\", stringify!($target)\u001b[0m\u001b[0m\u001b[38;5;9m)\u001b[0m\u001b[0m );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m178\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m                         \"{}::get_block: out of bounds\", stringify!($target) );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"panic message is not a string literal","code":{"code":"non_fmt_panics","explanation":null},"level":"warning","spans":[{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2626,"byte_end":2678,"line_start":90,"line_end":90,"column_start":30,"column_end":82,"is_primary":true,"text":[{"text":"                             format!(\"{}::slice: bad range\", stringify!($target)) );","highlight_start":30,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":5633,"byte_end":5765,"line_start":205,"line_end":207,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        impl_bit_sliceable_adapter! {","highlight_start":9,"highlight_end":38},{"text":"            impl['a, T: Bits, U: Bits<Block = T::Block>] BitSliceable for &'a $target<T, U>;","highlight_start":1,"highlight_end":93},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":6151,"byte_end":6183,"line_start":223,"line_end":223,"column_start":1,"column_end":33,"is_primary":false,"text":[{"text":"impl_bits_bin_op!(BitXor as ^ ^);","highlight_start":1,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bits_bin_op!","def_site_span":{"file_name":"src/adapter/logic.rs","byte_start":3936,"byte_end":3965,"line_start":158,"line_end":158,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! impl_bits_bin_op {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"impl_bit_sliceable_adapter!","def_site_span":{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2157,"byte_end":2196,"line_start":78,"line_end":78,"column_start":1,"column_end":40,"is_primary":false,"text":[{"text":"macro_rules! impl_bit_sliceable_adapter {","highlight_start":1,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the `assert!()` macro supports formatting, so there's no need for the `format!()` macro here","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the `format!(..)` macro call","code":null,"level":"help","spans":[{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2626,"byte_end":2634,"line_start":90,"line_end":90,"column_start":30,"column_end":38,"is_primary":true,"text":[{"text":"                             format!(\"{}::slice: bad range\", stringify!($target)) );","highlight_start":30,"highlight_end":38}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":5633,"byte_end":5765,"line_start":205,"line_end":207,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        impl_bit_sliceable_adapter! {","highlight_start":9,"highlight_end":38},{"text":"            impl['a, T: Bits, U: Bits<Block = T::Block>] BitSliceable for &'a $target<T, U>;","highlight_start":1,"highlight_end":93},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":6151,"byte_end":6183,"line_start":223,"line_end":223,"column_start":1,"column_end":33,"is_primary":false,"text":[{"text":"impl_bits_bin_op!(BitXor as ^ ^);","highlight_start":1,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bits_bin_op!","def_site_span":{"file_name":"src/adapter/logic.rs","byte_start":3936,"byte_end":3965,"line_start":158,"line_end":158,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! impl_bits_bin_op {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"impl_bit_sliceable_adapter!","def_site_span":{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2157,"byte_end":2196,"line_start":78,"line_end":78,"column_start":1,"column_end":40,"is_primary":false,"text":[{"text":"macro_rules! impl_bit_sliceable_adapter {","highlight_start":1,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2677,"byte_end":2678,"line_start":90,"line_end":90,"column_start":81,"column_end":82,"is_primary":true,"text":[{"text":"                             format!(\"{}::slice: bad range\", stringify!($target)) );","highlight_start":81,"highlight_end":82}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":5633,"byte_end":5765,"line_start":205,"line_end":207,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        impl_bit_sliceable_adapter! {","highlight_start":9,"highlight_end":38},{"text":"            impl['a, T: Bits, U: Bits<Block = T::Block>] BitSliceable for &'a $target<T, U>;","highlight_start":1,"highlight_end":93},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":6151,"byte_end":6183,"line_start":223,"line_end":223,"column_start":1,"column_end":33,"is_primary":false,"text":[{"text":"impl_bits_bin_op!(BitXor as ^ ^);","highlight_start":1,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bits_bin_op!","def_site_span":{"file_name":"src/adapter/logic.rs","byte_start":3936,"byte_end":3965,"line_start":158,"line_end":158,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! impl_bits_bin_op {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"impl_bit_sliceable_adapter!","def_site_span":{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2157,"byte_end":2196,"line_start":78,"line_end":78,"column_start":1,"column_end":40,"is_primary":false,"text":[{"text":"macro_rules! impl_bit_sliceable_adapter {","highlight_start":1,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: panic message is not a string literal\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/adapter/bit_slice_adapter.rs:90:30\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m90\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   format!(\"{}::slice: bad range\", stringify!($target)) );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/adapter/logic.rs:223:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m223\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_bits_bin_op!(BitXor as ^ ^);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the `assert!()` macro supports formatting, so there's no need for the `format!()` macro here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this warning originates in the macro `impl_bit_sliceable_adapter` which comes from the expansion of the macro `impl_bits_bin_op` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: remove the `format!(..)` macro call\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m90\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[38;5;9mformat!(\u001b[0m\u001b[0m\"{}::slice: bad range\", stringify!($target)\u001b[0m\u001b[0m\u001b[38;5;9m)\u001b[0m\u001b[0m );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m90\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m                             \"{}::slice: bad range\", stringify!($target) );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"panic message is not a string literal","code":{"code":"non_fmt_panics","explanation":null},"level":"warning","spans":[{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2626,"byte_end":2678,"line_start":90,"line_end":90,"column_start":30,"column_end":82,"is_primary":true,"text":[{"text":"                             format!(\"{}::slice: bad range\", stringify!($target)) );","highlight_start":30,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":7447,"byte_end":7621,"line_start":269,"line_end":273,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"impl_bit_sliceable_adapter! {","highlight_start":1,"highlight_end":30},{"text":"    impl['a, T: Bits, U: Bits<Block = T::Block>,","highlight_start":1,"highlight_end":49},{"text":"         F: Fn(T::Block, T::Block) -> T::Block]","highlight_start":1,"highlight_end":48},{"text":"        BitSliceable for &'a BitZip<T, U, F>;","highlight_start":1,"highlight_end":46},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bit_sliceable_adapter!","def_site_span":{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2157,"byte_end":2196,"line_start":78,"line_end":78,"column_start":1,"column_end":40,"is_primary":false,"text":[{"text":"macro_rules! impl_bit_sliceable_adapter {","highlight_start":1,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the `assert!()` macro supports formatting, so there's no need for the `format!()` macro here","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the `format!(..)` macro call","code":null,"level":"help","spans":[{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2626,"byte_end":2634,"line_start":90,"line_end":90,"column_start":30,"column_end":38,"is_primary":true,"text":[{"text":"                             format!(\"{}::slice: bad range\", stringify!($target)) );","highlight_start":30,"highlight_end":38}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":7447,"byte_end":7621,"line_start":269,"line_end":273,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"impl_bit_sliceable_adapter! {","highlight_start":1,"highlight_end":30},{"text":"    impl['a, T: Bits, U: Bits<Block = T::Block>,","highlight_start":1,"highlight_end":49},{"text":"         F: Fn(T::Block, T::Block) -> T::Block]","highlight_start":1,"highlight_end":48},{"text":"        BitSliceable for &'a BitZip<T, U, F>;","highlight_start":1,"highlight_end":46},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bit_sliceable_adapter!","def_site_span":{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2157,"byte_end":2196,"line_start":78,"line_end":78,"column_start":1,"column_end":40,"is_primary":false,"text":[{"text":"macro_rules! impl_bit_sliceable_adapter {","highlight_start":1,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2677,"byte_end":2678,"line_start":90,"line_end":90,"column_start":81,"column_end":82,"is_primary":true,"text":[{"text":"                             format!(\"{}::slice: bad range\", stringify!($target)) );","highlight_start":81,"highlight_end":82}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"src/adapter/logic.rs","byte_start":7447,"byte_end":7621,"line_start":269,"line_end":273,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"impl_bit_sliceable_adapter! {","highlight_start":1,"highlight_end":30},{"text":"    impl['a, T: Bits, U: Bits<Block = T::Block>,","highlight_start":1,"highlight_end":49},{"text":"         F: Fn(T::Block, T::Block) -> T::Block]","highlight_start":1,"highlight_end":48},{"text":"        BitSliceable for &'a BitZip<T, U, F>;","highlight_start":1,"highlight_end":46},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bit_sliceable_adapter!","def_site_span":{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2157,"byte_end":2196,"line_start":78,"line_end":78,"column_start":1,"column_end":40,"is_primary":false,"text":[{"text":"macro_rules! impl_bit_sliceable_adapter {","highlight_start":1,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: panic message is not a string literal\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/adapter/bit_slice_adapter.rs:90:30\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m90\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   format!(\"{}::slice: bad range\", stringify!($target)) );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/adapter/logic.rs:269:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m269\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_bit_sliceable_adapter! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m270\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    impl['a, T: Bits, U: Bits<Block = T::Block>,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m271\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m         F: Fn(T::Block, T::Block) -> T::Block]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m272\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        BitSliceable for &'a BitZip<T, U, F>;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m273\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the `assert!()` macro supports formatting, so there's no need for the `format!()` macro here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this warning originates in the macro `impl_bit_sliceable_adapter` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: remove the `format!(..)` macro call\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m90\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[38;5;9mformat!(\u001b[0m\u001b[0m\"{}::slice: bad range\", stringify!($target)\u001b[0m\u001b[0m\u001b[38;5;9m)\u001b[0m\u001b[0m );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m90\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m                             \"{}::slice: bad range\", stringify!($target) );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"panic message is not a string literal","code":{"code":"non_fmt_panics","explanation":null},"level":"warning","spans":[{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2626,"byte_end":2678,"line_start":90,"line_end":90,"column_start":30,"column_end":82,"is_primary":true,"text":[{"text":"                             format!(\"{}::slice: bad range\", stringify!($target)) );","highlight_start":30,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/adapter/bit_fill.rs","byte_start":1777,"byte_end":1936,"line_start":74,"line_end":77,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"impl_bit_sliceable_adapter! {","highlight_start":1,"highlight_end":30},{"text":"    impl[Block: BlockType] BitSliceable for BitFill<Block>;","highlight_start":1,"highlight_end":60},{"text":"    impl['a, Block: BlockType] BitSliceable for &'a BitFill<Block>;","highlight_start":1,"highlight_end":68},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bit_sliceable_adapter!","def_site_span":{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2157,"byte_end":2196,"line_start":78,"line_end":78,"column_start":1,"column_end":40,"is_primary":false,"text":[{"text":"macro_rules! impl_bit_sliceable_adapter {","highlight_start":1,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the `assert!()` macro supports formatting, so there's no need for the `format!()` macro here","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the `format!(..)` macro call","code":null,"level":"help","spans":[{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2626,"byte_end":2634,"line_start":90,"line_end":90,"column_start":30,"column_end":38,"is_primary":true,"text":[{"text":"                             format!(\"{}::slice: bad range\", stringify!($target)) );","highlight_start":30,"highlight_end":38}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"src/adapter/bit_fill.rs","byte_start":1777,"byte_end":1936,"line_start":74,"line_end":77,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"impl_bit_sliceable_adapter! {","highlight_start":1,"highlight_end":30},{"text":"    impl[Block: BlockType] BitSliceable for BitFill<Block>;","highlight_start":1,"highlight_end":60},{"text":"    impl['a, Block: BlockType] BitSliceable for &'a BitFill<Block>;","highlight_start":1,"highlight_end":68},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bit_sliceable_adapter!","def_site_span":{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2157,"byte_end":2196,"line_start":78,"line_end":78,"column_start":1,"column_end":40,"is_primary":false,"text":[{"text":"macro_rules! impl_bit_sliceable_adapter {","highlight_start":1,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2677,"byte_end":2678,"line_start":90,"line_end":90,"column_start":81,"column_end":82,"is_primary":true,"text":[{"text":"                             format!(\"{}::slice: bad range\", stringify!($target)) );","highlight_start":81,"highlight_end":82}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"src/adapter/bit_fill.rs","byte_start":1777,"byte_end":1936,"line_start":74,"line_end":77,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"impl_bit_sliceable_adapter! {","highlight_start":1,"highlight_end":30},{"text":"    impl[Block: BlockType] BitSliceable for BitFill<Block>;","highlight_start":1,"highlight_end":60},{"text":"    impl['a, Block: BlockType] BitSliceable for &'a BitFill<Block>;","highlight_start":1,"highlight_end":68},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bit_sliceable_adapter!","def_site_span":{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2157,"byte_end":2196,"line_start":78,"line_end":78,"column_start":1,"column_end":40,"is_primary":false,"text":[{"text":"macro_rules! impl_bit_sliceable_adapter {","highlight_start":1,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: panic message is not a string literal\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/adapter/bit_slice_adapter.rs:90:30\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m90\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   format!(\"{}::slice: bad range\", stringify!($target)) );\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/adapter/bit_fill.rs:74:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m74\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_bit_sliceable_adapter! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m75\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    impl[Block: BlockType] BitSliceable for BitFill<Block>;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m76\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    impl['a, Block: BlockType] BitSliceable for &'a BitFill<Block>;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m77\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the `assert!()` macro supports formatting, so there's no need for the `format!()` macro here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this warning originates in the macro `impl_bit_sliceable_adapter` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: remove the `format!(..)` macro call\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m90\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[38;5;9mformat!(\u001b[0m\u001b[0m\"{}::slice: bad range\", stringify!($target)\u001b[0m\u001b[0m\u001b[38;5;9m)\u001b[0m\u001b[0m );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m90\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m                             \"{}::slice: bad range\", stringify!($target) );\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"panic message is not a string literal","code":{"code":"non_fmt_panics","explanation":null},"level":"warning","spans":[{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2626,"byte_end":2678,"line_start":90,"line_end":90,"column_start":30,"column_end":82,"is_primary":true,"text":[{"text":"                             format!(\"{}::slice: bad range\", stringify!($target)) );","highlight_start":30,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/adapter/bit_concat.rs","byte_start":1972,"byte_end":2169,"line_start":73,"line_end":76,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"impl_bit_sliceable_adapter! {","highlight_start":1,"highlight_end":30},{"text":"    impl[T: Bits, U: Bits<Block = T::Block>] BitSliceable for BitConcat<T, U>;","highlight_start":1,"highlight_end":79},{"text":"    impl['a, T: Bits, U: Bits<Block = T::Block>] BitSliceable for &'a BitConcat<T, U>;","highlight_start":1,"highlight_end":87},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bit_sliceable_adapter!","def_site_span":{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2157,"byte_end":2196,"line_start":78,"line_end":78,"column_start":1,"column_end":40,"is_primary":false,"text":[{"text":"macro_rules! impl_bit_sliceable_adapter {","highlight_start":1,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the `assert!()` macro supports formatting, so there's no need for the `format!()` macro here","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the `format!(..)` macro call","code":null,"level":"help","spans":[{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2626,"byte_end":2634,"line_start":90,"line_end":90,"column_start":30,"column_end":38,"is_primary":true,"text":[{"text":"                             format!(\"{}::slice: bad range\", stringify!($target)) );","highlight_start":30,"highlight_end":38}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"src/adapter/bit_concat.rs","byte_start":1972,"byte_end":2169,"line_start":73,"line_end":76,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"impl_bit_sliceable_adapter! {","highlight_start":1,"highlight_end":30},{"text":"    impl[T: Bits, U: Bits<Block = T::Block>] BitSliceable for BitConcat<T, U>;","highlight_start":1,"highlight_end":79},{"text":"    impl['a, T: Bits, U: Bits<Block = T::Block>] BitSliceable for &'a BitConcat<T, U>;","highlight_start":1,"highlight_end":87},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bit_sliceable_adapter!","def_site_span":{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2157,"byte_end":2196,"line_start":78,"line_end":78,"column_start":1,"column_end":40,"is_primary":false,"text":[{"text":"macro_rules! impl_bit_sliceable_adapter {","highlight_start":1,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2677,"byte_end":2678,"line_start":90,"line_end":90,"column_start":81,"column_end":82,"is_primary":true,"text":[{"text":"                             format!(\"{}::slice: bad range\", stringify!($target)) );","highlight_start":81,"highlight_end":82}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"src/adapter/bit_concat.rs","byte_start":1972,"byte_end":2169,"line_start":73,"line_end":76,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"impl_bit_sliceable_adapter! {","highlight_start":1,"highlight_end":30},{"text":"    impl[T: Bits, U: Bits<Block = T::Block>] BitSliceable for BitConcat<T, U>;","highlight_start":1,"highlight_end":79},{"text":"    impl['a, T: Bits, U: Bits<Block = T::Block>] BitSliceable for &'a BitConcat<T, U>;","highlight_start":1,"highlight_end":87},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_bit_sliceable_adapter!","def_site_span":{"file_name":"src/adapter/bit_slice_adapter.rs","byte_start":2157,"byte_end":2196,"line_start":78,"line_end":78,"column_start":1,"column_end":40,"is_primary":false,"text":[{"text":"macro_rules! impl_bit_sliceable_adapter {","highlight_start":1,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: panic message is not a string literal\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/adapter/bit_slice_adapter.rs:90:30\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m90\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   format!(\"{}::slice: bad range\", stringify!($target)) );\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/adapter/bit_concat.rs:73:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m73\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_bit_sliceable_adapter! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m74\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    impl[T: Bits, U: Bits<Block = T::Block>] BitSliceable for BitConcat<T, U>;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m75\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    impl['a, T: Bits, U: Bits<Block = T::Block>] BitSliceable for &'a BitConcat<T, U>;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m76\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the `assert!()` macro supports formatting, so there's no need for the `format!()` macro here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this warning originates in the macro `impl_bit_sliceable_adapter` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: remove the `format!(..)` macro call\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m90\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[38;5;9mformat!(\u001b[0m\u001b[0m\"{}::slice: bad range\", stringify!($target)\u001b[0m\u001b[0m\u001b[38;5;9m)\u001b[0m\u001b[0m );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m90\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m                             \"{}::slice: bad range\", stringify!($target) );\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"16 warnings emitted","code":null,"level":"warning","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: 16 warnings emitted\u001b[0m\n\n"}
